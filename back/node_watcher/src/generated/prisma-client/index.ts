// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  blockNumber: (where?: BlockNumberWhereInput) => Promise<boolean>;
  era: (where?: EraWhereInput) => Promise<boolean>;
  nomination: (where?: NominationWhereInput) => Promise<boolean>;
  preimage: (where?: PreimageWhereInput) => Promise<boolean>;
  preimageArgument: (where?: PreimageArgumentWhereInput) => Promise<boolean>;
  preimageStatus: (where?: PreimageStatusWhereInput) => Promise<boolean>;
  proposal: (where?: ProposalWhereInput) => Promise<boolean>;
  proposalArgument: (where?: ProposalArgumentWhereInput) => Promise<boolean>;
  reward: (where?: RewardWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  slashing: (where?: SlashingWhereInput) => Promise<boolean>;
  stake: (where?: StakeWhereInput) => Promise<boolean>;
  totalIssuance: (where?: TotalIssuanceWhereInput) => Promise<boolean>;
  validator: (where?: ValidatorWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  blockNumber: (
    where: BlockNumberWhereUniqueInput
  ) => BlockNumberNullablePromise;
  blockNumbers: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BlockNumber>;
  blockNumbersConnection: (args?: {
    where?: BlockNumberWhereInput;
    orderBy?: BlockNumberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BlockNumberConnectionPromise;
  era: (where: EraWhereUniqueInput) => EraNullablePromise;
  eras: (args?: {
    where?: EraWhereInput;
    orderBy?: EraOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Era>;
  erasConnection: (args?: {
    where?: EraWhereInput;
    orderBy?: EraOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EraConnectionPromise;
  nomination: (where: NominationWhereUniqueInput) => NominationNullablePromise;
  nominations: (args?: {
    where?: NominationWhereInput;
    orderBy?: NominationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Nomination>;
  nominationsConnection: (args?: {
    where?: NominationWhereInput;
    orderBy?: NominationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NominationConnectionPromise;
  preimage: (where: PreimageWhereUniqueInput) => PreimageNullablePromise;
  preimages: (args?: {
    where?: PreimageWhereInput;
    orderBy?: PreimageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Preimage>;
  preimagesConnection: (args?: {
    where?: PreimageWhereInput;
    orderBy?: PreimageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreimageConnectionPromise;
  preimageArgument: (
    where: PreimageArgumentWhereUniqueInput
  ) => PreimageArgumentNullablePromise;
  preimageArguments: (args?: {
    where?: PreimageArgumentWhereInput;
    orderBy?: PreimageArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PreimageArgument>;
  preimageArgumentsConnection: (args?: {
    where?: PreimageArgumentWhereInput;
    orderBy?: PreimageArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreimageArgumentConnectionPromise;
  preimageStatus: (
    where: PreimageStatusWhereUniqueInput
  ) => PreimageStatusNullablePromise;
  preimageStatuses: (args?: {
    where?: PreimageStatusWhereInput;
    orderBy?: PreimageStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PreimageStatus>;
  preimageStatusesConnection: (args?: {
    where?: PreimageStatusWhereInput;
    orderBy?: PreimageStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreimageStatusConnectionPromise;
  proposal: (where: ProposalWhereUniqueInput) => ProposalNullablePromise;
  proposals: (args?: {
    where?: ProposalWhereInput;
    orderBy?: ProposalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Proposal>;
  proposalsConnection: (args?: {
    where?: ProposalWhereInput;
    orderBy?: ProposalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProposalConnectionPromise;
  proposalArgument: (
    where: ProposalArgumentWhereUniqueInput
  ) => ProposalArgumentNullablePromise;
  proposalArguments: (args?: {
    where?: ProposalArgumentWhereInput;
    orderBy?: ProposalArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProposalArgument>;
  proposalArgumentsConnection: (args?: {
    where?: ProposalArgumentWhereInput;
    orderBy?: ProposalArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProposalArgumentConnectionPromise;
  reward: (where: RewardWhereUniqueInput) => RewardNullablePromise;
  rewards: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reward>;
  rewardsConnection: (args?: {
    where?: RewardWhereInput;
    orderBy?: RewardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RewardConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  slashing: (where: SlashingWhereUniqueInput) => SlashingNullablePromise;
  slashings: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Slashing>;
  slashingsConnection: (args?: {
    where?: SlashingWhereInput;
    orderBy?: SlashingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SlashingConnectionPromise;
  stake: (where: StakeWhereUniqueInput) => StakeNullablePromise;
  stakes: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stake>;
  stakesConnection: (args?: {
    where?: StakeWhereInput;
    orderBy?: StakeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StakeConnectionPromise;
  totalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuanceNullablePromise;
  totalIssuances: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TotalIssuance>;
  totalIssuancesConnection: (args?: {
    where?: TotalIssuanceWhereInput;
    orderBy?: TotalIssuanceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TotalIssuanceConnectionPromise;
  validator: (where: ValidatorWhereUniqueInput) => ValidatorNullablePromise;
  validators: (args?: {
    where?: ValidatorWhereInput;
    orderBy?: ValidatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Validator>;
  validatorsConnection: (args?: {
    where?: ValidatorWhereInput;
    orderBy?: ValidatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValidatorConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBlockNumber: (data: BlockNumberCreateInput) => BlockNumberPromise;
  updateBlockNumber: (args: {
    data: BlockNumberUpdateInput;
    where: BlockNumberWhereUniqueInput;
  }) => BlockNumberPromise;
  updateManyBlockNumbers: (args: {
    data: BlockNumberUpdateManyMutationInput;
    where?: BlockNumberWhereInput;
  }) => BatchPayloadPromise;
  upsertBlockNumber: (args: {
    where: BlockNumberWhereUniqueInput;
    create: BlockNumberCreateInput;
    update: BlockNumberUpdateInput;
  }) => BlockNumberPromise;
  deleteBlockNumber: (where: BlockNumberWhereUniqueInput) => BlockNumberPromise;
  deleteManyBlockNumbers: (
    where?: BlockNumberWhereInput
  ) => BatchPayloadPromise;
  createEra: (data: EraCreateInput) => EraPromise;
  updateEra: (args: {
    data: EraUpdateInput;
    where: EraWhereUniqueInput;
  }) => EraPromise;
  updateManyEras: (args: {
    data: EraUpdateManyMutationInput;
    where?: EraWhereInput;
  }) => BatchPayloadPromise;
  upsertEra: (args: {
    where: EraWhereUniqueInput;
    create: EraCreateInput;
    update: EraUpdateInput;
  }) => EraPromise;
  deleteEra: (where: EraWhereUniqueInput) => EraPromise;
  deleteManyEras: (where?: EraWhereInput) => BatchPayloadPromise;
  createNomination: (data: NominationCreateInput) => NominationPromise;
  updateNomination: (args: {
    data: NominationUpdateInput;
    where: NominationWhereUniqueInput;
  }) => NominationPromise;
  updateManyNominations: (args: {
    data: NominationUpdateManyMutationInput;
    where?: NominationWhereInput;
  }) => BatchPayloadPromise;
  upsertNomination: (args: {
    where: NominationWhereUniqueInput;
    create: NominationCreateInput;
    update: NominationUpdateInput;
  }) => NominationPromise;
  deleteNomination: (where: NominationWhereUniqueInput) => NominationPromise;
  deleteManyNominations: (where?: NominationWhereInput) => BatchPayloadPromise;
  createPreimage: (data: PreimageCreateInput) => PreimagePromise;
  updatePreimage: (args: {
    data: PreimageUpdateInput;
    where: PreimageWhereUniqueInput;
  }) => PreimagePromise;
  updateManyPreimages: (args: {
    data: PreimageUpdateManyMutationInput;
    where?: PreimageWhereInput;
  }) => BatchPayloadPromise;
  upsertPreimage: (args: {
    where: PreimageWhereUniqueInput;
    create: PreimageCreateInput;
    update: PreimageUpdateInput;
  }) => PreimagePromise;
  deletePreimage: (where: PreimageWhereUniqueInput) => PreimagePromise;
  deleteManyPreimages: (where?: PreimageWhereInput) => BatchPayloadPromise;
  createPreimageArgument: (
    data: PreimageArgumentCreateInput
  ) => PreimageArgumentPromise;
  updatePreimageArgument: (args: {
    data: PreimageArgumentUpdateInput;
    where: PreimageArgumentWhereUniqueInput;
  }) => PreimageArgumentPromise;
  updateManyPreimageArguments: (args: {
    data: PreimageArgumentUpdateManyMutationInput;
    where?: PreimageArgumentWhereInput;
  }) => BatchPayloadPromise;
  upsertPreimageArgument: (args: {
    where: PreimageArgumentWhereUniqueInput;
    create: PreimageArgumentCreateInput;
    update: PreimageArgumentUpdateInput;
  }) => PreimageArgumentPromise;
  deletePreimageArgument: (
    where: PreimageArgumentWhereUniqueInput
  ) => PreimageArgumentPromise;
  deleteManyPreimageArguments: (
    where?: PreimageArgumentWhereInput
  ) => BatchPayloadPromise;
  createPreimageStatus: (
    data: PreimageStatusCreateInput
  ) => PreimageStatusPromise;
  updatePreimageStatus: (args: {
    data: PreimageStatusUpdateInput;
    where: PreimageStatusWhereUniqueInput;
  }) => PreimageStatusPromise;
  updateManyPreimageStatuses: (args: {
    data: PreimageStatusUpdateManyMutationInput;
    where?: PreimageStatusWhereInput;
  }) => BatchPayloadPromise;
  upsertPreimageStatus: (args: {
    where: PreimageStatusWhereUniqueInput;
    create: PreimageStatusCreateInput;
    update: PreimageStatusUpdateInput;
  }) => PreimageStatusPromise;
  deletePreimageStatus: (
    where: PreimageStatusWhereUniqueInput
  ) => PreimageStatusPromise;
  deleteManyPreimageStatuses: (
    where?: PreimageStatusWhereInput
  ) => BatchPayloadPromise;
  createProposal: (data: ProposalCreateInput) => ProposalPromise;
  updateProposal: (args: {
    data: ProposalUpdateInput;
    where: ProposalWhereUniqueInput;
  }) => ProposalPromise;
  updateManyProposals: (args: {
    data: ProposalUpdateManyMutationInput;
    where?: ProposalWhereInput;
  }) => BatchPayloadPromise;
  upsertProposal: (args: {
    where: ProposalWhereUniqueInput;
    create: ProposalCreateInput;
    update: ProposalUpdateInput;
  }) => ProposalPromise;
  deleteProposal: (where: ProposalWhereUniqueInput) => ProposalPromise;
  deleteManyProposals: (where?: ProposalWhereInput) => BatchPayloadPromise;
  createProposalArgument: (
    data: ProposalArgumentCreateInput
  ) => ProposalArgumentPromise;
  updateProposalArgument: (args: {
    data: ProposalArgumentUpdateInput;
    where: ProposalArgumentWhereUniqueInput;
  }) => ProposalArgumentPromise;
  updateManyProposalArguments: (args: {
    data: ProposalArgumentUpdateManyMutationInput;
    where?: ProposalArgumentWhereInput;
  }) => BatchPayloadPromise;
  upsertProposalArgument: (args: {
    where: ProposalArgumentWhereUniqueInput;
    create: ProposalArgumentCreateInput;
    update: ProposalArgumentUpdateInput;
  }) => ProposalArgumentPromise;
  deleteProposalArgument: (
    where: ProposalArgumentWhereUniqueInput
  ) => ProposalArgumentPromise;
  deleteManyProposalArguments: (
    where?: ProposalArgumentWhereInput
  ) => BatchPayloadPromise;
  createReward: (data: RewardCreateInput) => RewardPromise;
  updateReward: (args: {
    data: RewardUpdateInput;
    where: RewardWhereUniqueInput;
  }) => RewardPromise;
  updateManyRewards: (args: {
    data: RewardUpdateManyMutationInput;
    where?: RewardWhereInput;
  }) => BatchPayloadPromise;
  upsertReward: (args: {
    where: RewardWhereUniqueInput;
    create: RewardCreateInput;
    update: RewardUpdateInput;
  }) => RewardPromise;
  deleteReward: (where: RewardWhereUniqueInput) => RewardPromise;
  deleteManyRewards: (where?: RewardWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSlashing: (data: SlashingCreateInput) => SlashingPromise;
  updateSlashing: (args: {
    data: SlashingUpdateInput;
    where: SlashingWhereUniqueInput;
  }) => SlashingPromise;
  updateManySlashings: (args: {
    data: SlashingUpdateManyMutationInput;
    where?: SlashingWhereInput;
  }) => BatchPayloadPromise;
  upsertSlashing: (args: {
    where: SlashingWhereUniqueInput;
    create: SlashingCreateInput;
    update: SlashingUpdateInput;
  }) => SlashingPromise;
  deleteSlashing: (where: SlashingWhereUniqueInput) => SlashingPromise;
  deleteManySlashings: (where?: SlashingWhereInput) => BatchPayloadPromise;
  createStake: (data: StakeCreateInput) => StakePromise;
  updateStake: (args: {
    data: StakeUpdateInput;
    where: StakeWhereUniqueInput;
  }) => StakePromise;
  updateManyStakes: (args: {
    data: StakeUpdateManyMutationInput;
    where?: StakeWhereInput;
  }) => BatchPayloadPromise;
  upsertStake: (args: {
    where: StakeWhereUniqueInput;
    create: StakeCreateInput;
    update: StakeUpdateInput;
  }) => StakePromise;
  deleteStake: (where: StakeWhereUniqueInput) => StakePromise;
  deleteManyStakes: (where?: StakeWhereInput) => BatchPayloadPromise;
  createTotalIssuance: (data: TotalIssuanceCreateInput) => TotalIssuancePromise;
  updateTotalIssuance: (args: {
    data: TotalIssuanceUpdateInput;
    where: TotalIssuanceWhereUniqueInput;
  }) => TotalIssuancePromise;
  updateManyTotalIssuances: (args: {
    data: TotalIssuanceUpdateManyMutationInput;
    where?: TotalIssuanceWhereInput;
  }) => BatchPayloadPromise;
  upsertTotalIssuance: (args: {
    where: TotalIssuanceWhereUniqueInput;
    create: TotalIssuanceCreateInput;
    update: TotalIssuanceUpdateInput;
  }) => TotalIssuancePromise;
  deleteTotalIssuance: (
    where: TotalIssuanceWhereUniqueInput
  ) => TotalIssuancePromise;
  deleteManyTotalIssuances: (
    where?: TotalIssuanceWhereInput
  ) => BatchPayloadPromise;
  createValidator: (data: ValidatorCreateInput) => ValidatorPromise;
  updateValidator: (args: {
    data: ValidatorUpdateInput;
    where: ValidatorWhereUniqueInput;
  }) => ValidatorPromise;
  updateManyValidators: (args: {
    data: ValidatorUpdateManyMutationInput;
    where?: ValidatorWhereInput;
  }) => BatchPayloadPromise;
  upsertValidator: (args: {
    where: ValidatorWhereUniqueInput;
    create: ValidatorCreateInput;
    update: ValidatorUpdateInput;
  }) => ValidatorPromise;
  deleteValidator: (where: ValidatorWhereUniqueInput) => ValidatorPromise;
  deleteManyValidators: (where?: ValidatorWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  blockNumber: (
    where?: BlockNumberSubscriptionWhereInput
  ) => BlockNumberSubscriptionPayloadSubscription;
  era: (
    where?: EraSubscriptionWhereInput
  ) => EraSubscriptionPayloadSubscription;
  nomination: (
    where?: NominationSubscriptionWhereInput
  ) => NominationSubscriptionPayloadSubscription;
  preimage: (
    where?: PreimageSubscriptionWhereInput
  ) => PreimageSubscriptionPayloadSubscription;
  preimageArgument: (
    where?: PreimageArgumentSubscriptionWhereInput
  ) => PreimageArgumentSubscriptionPayloadSubscription;
  preimageStatus: (
    where?: PreimageStatusSubscriptionWhereInput
  ) => PreimageStatusSubscriptionPayloadSubscription;
  proposal: (
    where?: ProposalSubscriptionWhereInput
  ) => ProposalSubscriptionPayloadSubscription;
  proposalArgument: (
    where?: ProposalArgumentSubscriptionWhereInput
  ) => ProposalArgumentSubscriptionPayloadSubscription;
  reward: (
    where?: RewardSubscriptionWhereInput
  ) => RewardSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  slashing: (
    where?: SlashingSubscriptionWhereInput
  ) => SlashingSubscriptionPayloadSubscription;
  stake: (
    where?: StakeSubscriptionWhereInput
  ) => StakeSubscriptionPayloadSubscription;
  totalIssuance: (
    where?: TotalIssuanceSubscriptionWhereInput
  ) => TotalIssuanceSubscriptionPayloadSubscription;
  validator: (
    where?: ValidatorSubscriptionWhereInput
  ) => ValidatorSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RewardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type EraOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC"
  | "totalPoints_ASC"
  | "totalPoints_DESC";

export type ProposalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "depositAmount_ASC"
  | "depositAmount_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "method_ASC"
  | "method_DESC"
  | "proposal_ASC"
  | "proposal_DESC"
  | "proposalId_ASC"
  | "proposalId_DESC"
  | "proposer_ASC"
  | "proposer_DESC"
  | "section_ASC"
  | "section_DESC";

export type ValidatorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "controller_ASC"
  | "controller_DESC"
  | "stash_ASC"
  | "stash_DESC"
  | "preferences_ASC"
  | "preferences_DESC";

export type PreimageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "author_ASC"
  | "author_DESC"
  | "depositAmount_ASC"
  | "depositAmount_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "method_ASC"
  | "method_DESC"
  | "section_ASC"
  | "section_DESC";

export type StakeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "totalStake_ASC"
  | "totalStake_DESC";

export type NominationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "validatorController_ASC"
  | "validatorController_DESC"
  | "validatorStash_ASC"
  | "validatorStash_DESC"
  | "nominatorController_ASC"
  | "nominatorController_DESC"
  | "nominatorStash_ASC"
  | "nominatorStash_DESC"
  | "bonded_ASC"
  | "bonded_DESC";

export type ProposalArgumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC";

export type PreimageArgumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC";

export type PreimageStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC";

export type SlashingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "who_ASC"
  | "who_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type TotalIssuanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC";

export type BlockNumberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "authoredBy_ASC"
  | "authoredBy_DESC"
  | "startDateTime_ASC"
  | "startDateTime_DESC"
  | "hash_ASC"
  | "hash_DESC";

export interface ProposalCreateOneWithoutPreimageInput {
  create?: Maybe<ProposalCreateWithoutPreimageInput>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export type BlockNumberWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  number?: Maybe<Int>;
  hash?: Maybe<String>;
}>;

export interface PreimageUpdateInput {
  author?: Maybe<String>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  proposal?: Maybe<ProposalUpdateOneWithoutPreimageInput>;
  preimageArguments?: Maybe<PreimageArgumentUpdateManyWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusUpdateManyWithoutPreimageInput>;
  section?: Maybe<String>;
}

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  start?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface TotalIssuanceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  AND?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  OR?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
  NOT?: Maybe<TotalIssuanceWhereInput[] | TotalIssuanceWhereInput>;
}

export interface PreimageCreateWithoutPreimageArgumentsInput {
  id?: Maybe<ID_Input>;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal?: Maybe<ProposalCreateOneWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusCreateManyWithoutPreimageInput>;
  section: String;
}

export interface PreimageStatusUpdateManyMutationInput {
  status?: Maybe<String>;
}

export interface ProposalUpdateOneWithoutPreimageInput {
  create?: Maybe<ProposalCreateWithoutPreimageInput>;
  update?: Maybe<ProposalUpdateWithoutPreimageDataInput>;
  upsert?: Maybe<ProposalUpsertWithoutPreimageInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export interface PreimageUpsertWithoutPreimageStatusInput {
  update: PreimageUpdateWithoutPreimageStatusDataInput;
  create: PreimageCreateWithoutPreimageStatusInput;
}

export type NominationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreimageUpdateWithoutPreimageStatusDataInput {
  author?: Maybe<String>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  proposal?: Maybe<ProposalUpdateOneWithoutPreimageInput>;
  preimageArguments?: Maybe<PreimageArgumentUpdateManyWithoutPreimageInput>;
  section?: Maybe<String>;
}

export interface NominationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  validatorController?: Maybe<String>;
  validatorController_not?: Maybe<String>;
  validatorController_in?: Maybe<String[] | String>;
  validatorController_not_in?: Maybe<String[] | String>;
  validatorController_lt?: Maybe<String>;
  validatorController_lte?: Maybe<String>;
  validatorController_gt?: Maybe<String>;
  validatorController_gte?: Maybe<String>;
  validatorController_contains?: Maybe<String>;
  validatorController_not_contains?: Maybe<String>;
  validatorController_starts_with?: Maybe<String>;
  validatorController_not_starts_with?: Maybe<String>;
  validatorController_ends_with?: Maybe<String>;
  validatorController_not_ends_with?: Maybe<String>;
  validatorStash?: Maybe<String>;
  validatorStash_not?: Maybe<String>;
  validatorStash_in?: Maybe<String[] | String>;
  validatorStash_not_in?: Maybe<String[] | String>;
  validatorStash_lt?: Maybe<String>;
  validatorStash_lte?: Maybe<String>;
  validatorStash_gt?: Maybe<String>;
  validatorStash_gte?: Maybe<String>;
  validatorStash_contains?: Maybe<String>;
  validatorStash_not_contains?: Maybe<String>;
  validatorStash_starts_with?: Maybe<String>;
  validatorStash_not_starts_with?: Maybe<String>;
  validatorStash_ends_with?: Maybe<String>;
  validatorStash_not_ends_with?: Maybe<String>;
  nominatorController?: Maybe<String>;
  nominatorController_not?: Maybe<String>;
  nominatorController_in?: Maybe<String[] | String>;
  nominatorController_not_in?: Maybe<String[] | String>;
  nominatorController_lt?: Maybe<String>;
  nominatorController_lte?: Maybe<String>;
  nominatorController_gt?: Maybe<String>;
  nominatorController_gte?: Maybe<String>;
  nominatorController_contains?: Maybe<String>;
  nominatorController_not_contains?: Maybe<String>;
  nominatorController_starts_with?: Maybe<String>;
  nominatorController_not_starts_with?: Maybe<String>;
  nominatorController_ends_with?: Maybe<String>;
  nominatorController_not_ends_with?: Maybe<String>;
  nominatorStash?: Maybe<String>;
  nominatorStash_not?: Maybe<String>;
  nominatorStash_in?: Maybe<String[] | String>;
  nominatorStash_not_in?: Maybe<String[] | String>;
  nominatorStash_lt?: Maybe<String>;
  nominatorStash_lte?: Maybe<String>;
  nominatorStash_gt?: Maybe<String>;
  nominatorStash_gte?: Maybe<String>;
  nominatorStash_contains?: Maybe<String>;
  nominatorStash_not_contains?: Maybe<String>;
  nominatorStash_starts_with?: Maybe<String>;
  nominatorStash_not_starts_with?: Maybe<String>;
  nominatorStash_ends_with?: Maybe<String>;
  nominatorStash_not_ends_with?: Maybe<String>;
  session?: Maybe<SessionWhereInput>;
  bonded?: Maybe<String>;
  bonded_not?: Maybe<String>;
  bonded_in?: Maybe<String[] | String>;
  bonded_not_in?: Maybe<String[] | String>;
  bonded_lt?: Maybe<String>;
  bonded_lte?: Maybe<String>;
  bonded_gt?: Maybe<String>;
  bonded_gte?: Maybe<String>;
  bonded_contains?: Maybe<String>;
  bonded_not_contains?: Maybe<String>;
  bonded_starts_with?: Maybe<String>;
  bonded_not_starts_with?: Maybe<String>;
  bonded_ends_with?: Maybe<String>;
  bonded_not_ends_with?: Maybe<String>;
  AND?: Maybe<NominationWhereInput[] | NominationWhereInput>;
  OR?: Maybe<NominationWhereInput[] | NominationWhereInput>;
  NOT?: Maybe<NominationWhereInput[] | NominationWhereInput>;
}

export interface PreimageUpdateOneRequiredWithoutPreimageStatusInput {
  create?: Maybe<PreimageCreateWithoutPreimageStatusInput>;
  update?: Maybe<PreimageUpdateWithoutPreimageStatusDataInput>;
  upsert?: Maybe<PreimageUpsertWithoutPreimageStatusInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface SlashingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SlashingWhereInput>;
  AND?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
  OR?: Maybe<SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput>;
  NOT?: Maybe<
    SlashingSubscriptionWhereInput[] | SlashingSubscriptionWhereInput
  >;
}

export type ValidatorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RewardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RewardWhereInput>;
  AND?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  OR?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
  NOT?: Maybe<RewardSubscriptionWhereInput[] | RewardSubscriptionWhereInput>;
}

export interface PreimageStatusUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  preimage?: Maybe<PreimageUpdateOneRequiredWithoutPreimageStatusInput>;
  status?: Maybe<String>;
}

export interface ProposalArgumentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProposalArgumentWhereInput>;
  AND?: Maybe<
    | ProposalArgumentSubscriptionWhereInput[]
    | ProposalArgumentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProposalArgumentSubscriptionWhereInput[]
    | ProposalArgumentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProposalArgumentSubscriptionWhereInput[]
    | ProposalArgumentSubscriptionWhereInput
  >;
}

export interface ValidatorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  session?: Maybe<SessionWhereInput>;
  controller?: Maybe<String>;
  controller_not?: Maybe<String>;
  controller_in?: Maybe<String[] | String>;
  controller_not_in?: Maybe<String[] | String>;
  controller_lt?: Maybe<String>;
  controller_lte?: Maybe<String>;
  controller_gt?: Maybe<String>;
  controller_gte?: Maybe<String>;
  controller_contains?: Maybe<String>;
  controller_not_contains?: Maybe<String>;
  controller_starts_with?: Maybe<String>;
  controller_not_starts_with?: Maybe<String>;
  controller_ends_with?: Maybe<String>;
  controller_not_ends_with?: Maybe<String>;
  stash?: Maybe<String>;
  stash_not?: Maybe<String>;
  stash_in?: Maybe<String[] | String>;
  stash_not_in?: Maybe<String[] | String>;
  stash_lt?: Maybe<String>;
  stash_lte?: Maybe<String>;
  stash_gt?: Maybe<String>;
  stash_gte?: Maybe<String>;
  stash_contains?: Maybe<String>;
  stash_not_contains?: Maybe<String>;
  stash_starts_with?: Maybe<String>;
  stash_not_starts_with?: Maybe<String>;
  stash_ends_with?: Maybe<String>;
  stash_not_ends_with?: Maybe<String>;
  preferences?: Maybe<String>;
  preferences_not?: Maybe<String>;
  preferences_in?: Maybe<String[] | String>;
  preferences_not_in?: Maybe<String[] | String>;
  preferences_lt?: Maybe<String>;
  preferences_lte?: Maybe<String>;
  preferences_gt?: Maybe<String>;
  preferences_gte?: Maybe<String>;
  preferences_contains?: Maybe<String>;
  preferences_not_contains?: Maybe<String>;
  preferences_starts_with?: Maybe<String>;
  preferences_not_starts_with?: Maybe<String>;
  preferences_ends_with?: Maybe<String>;
  preferences_not_ends_with?: Maybe<String>;
  AND?: Maybe<ValidatorWhereInput[] | ValidatorWhereInput>;
  OR?: Maybe<ValidatorWhereInput[] | ValidatorWhereInput>;
  NOT?: Maybe<ValidatorWhereInput[] | ValidatorWhereInput>;
}

export interface ProposalArgumentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  proposal?: Maybe<ProposalWhereInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProposalArgumentWhereInput[] | ProposalArgumentWhereInput>;
  OR?: Maybe<ProposalArgumentWhereInput[] | ProposalArgumentWhereInput>;
  NOT?: Maybe<ProposalArgumentWhereInput[] | ProposalArgumentWhereInput>;
}

export interface PreimageCreateWithoutPreimageStatusInput {
  id?: Maybe<ID_Input>;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal?: Maybe<ProposalCreateOneWithoutPreimageInput>;
  preimageArguments?: Maybe<PreimageArgumentCreateManyWithoutPreimageInput>;
  section: String;
}

export interface PreimageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  author?: Maybe<String>;
  author_not?: Maybe<String>;
  author_in?: Maybe<String[] | String>;
  author_not_in?: Maybe<String[] | String>;
  author_lt?: Maybe<String>;
  author_lte?: Maybe<String>;
  author_gt?: Maybe<String>;
  author_gte?: Maybe<String>;
  author_contains?: Maybe<String>;
  author_not_contains?: Maybe<String>;
  author_starts_with?: Maybe<String>;
  author_not_starts_with?: Maybe<String>;
  author_ends_with?: Maybe<String>;
  author_not_ends_with?: Maybe<String>;
  depositAmount?: Maybe<String>;
  depositAmount_not?: Maybe<String>;
  depositAmount_in?: Maybe<String[] | String>;
  depositAmount_not_in?: Maybe<String[] | String>;
  depositAmount_lt?: Maybe<String>;
  depositAmount_lte?: Maybe<String>;
  depositAmount_gt?: Maybe<String>;
  depositAmount_gte?: Maybe<String>;
  depositAmount_contains?: Maybe<String>;
  depositAmount_not_contains?: Maybe<String>;
  depositAmount_starts_with?: Maybe<String>;
  depositAmount_not_starts_with?: Maybe<String>;
  depositAmount_ends_with?: Maybe<String>;
  depositAmount_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  metaDescription?: Maybe<String>;
  metaDescription_not?: Maybe<String>;
  metaDescription_in?: Maybe<String[] | String>;
  metaDescription_not_in?: Maybe<String[] | String>;
  metaDescription_lt?: Maybe<String>;
  metaDescription_lte?: Maybe<String>;
  metaDescription_gt?: Maybe<String>;
  metaDescription_gte?: Maybe<String>;
  metaDescription_contains?: Maybe<String>;
  metaDescription_not_contains?: Maybe<String>;
  metaDescription_starts_with?: Maybe<String>;
  metaDescription_not_starts_with?: Maybe<String>;
  metaDescription_ends_with?: Maybe<String>;
  metaDescription_not_ends_with?: Maybe<String>;
  method?: Maybe<String>;
  method_not?: Maybe<String>;
  method_in?: Maybe<String[] | String>;
  method_not_in?: Maybe<String[] | String>;
  method_lt?: Maybe<String>;
  method_lte?: Maybe<String>;
  method_gt?: Maybe<String>;
  method_gte?: Maybe<String>;
  method_contains?: Maybe<String>;
  method_not_contains?: Maybe<String>;
  method_starts_with?: Maybe<String>;
  method_not_starts_with?: Maybe<String>;
  method_ends_with?: Maybe<String>;
  method_not_ends_with?: Maybe<String>;
  proposal?: Maybe<ProposalWhereInput>;
  preimageArguments_every?: Maybe<PreimageArgumentWhereInput>;
  preimageArguments_some?: Maybe<PreimageArgumentWhereInput>;
  preimageArguments_none?: Maybe<PreimageArgumentWhereInput>;
  preimageStatus_every?: Maybe<PreimageStatusWhereInput>;
  preimageStatus_some?: Maybe<PreimageStatusWhereInput>;
  preimageStatus_none?: Maybe<PreimageStatusWhereInput>;
  section?: Maybe<String>;
  section_not?: Maybe<String>;
  section_in?: Maybe<String[] | String>;
  section_not_in?: Maybe<String[] | String>;
  section_lt?: Maybe<String>;
  section_lte?: Maybe<String>;
  section_gt?: Maybe<String>;
  section_gte?: Maybe<String>;
  section_contains?: Maybe<String>;
  section_not_contains?: Maybe<String>;
  section_starts_with?: Maybe<String>;
  section_not_starts_with?: Maybe<String>;
  section_ends_with?: Maybe<String>;
  section_not_ends_with?: Maybe<String>;
  AND?: Maybe<PreimageWhereInput[] | PreimageWhereInput>;
  OR?: Maybe<PreimageWhereInput[] | PreimageWhereInput>;
  NOT?: Maybe<PreimageWhereInput[] | PreimageWhereInput>;
}

export interface PreimageCreateOneWithoutPreimageStatusInput {
  create?: Maybe<PreimageCreateWithoutPreimageStatusInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface PreimageStatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  preimage?: Maybe<PreimageWhereInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<PreimageStatusWhereInput[] | PreimageStatusWhereInput>;
  OR?: Maybe<PreimageStatusWhereInput[] | PreimageStatusWhereInput>;
  NOT?: Maybe<PreimageStatusWhereInput[] | PreimageStatusWhereInput>;
}

export interface PreimageStatusCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  preimage: PreimageCreateOneWithoutPreimageStatusInput;
  status: String;
}

export interface PreimageArgumentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreimageArgumentWhereInput>;
  AND?: Maybe<
    | PreimageArgumentSubscriptionWhereInput[]
    | PreimageArgumentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PreimageArgumentSubscriptionWhereInput[]
    | PreimageArgumentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PreimageArgumentSubscriptionWhereInput[]
    | PreimageArgumentSubscriptionWhereInput
  >;
}

export interface PreimageArgumentUpdateManyMutationInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export interface PreimageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreimageWhereInput>;
  AND?: Maybe<
    PreimageSubscriptionWhereInput[] | PreimageSubscriptionWhereInput
  >;
  OR?: Maybe<PreimageSubscriptionWhereInput[] | PreimageSubscriptionWhereInput>;
  NOT?: Maybe<
    PreimageSubscriptionWhereInput[] | PreimageSubscriptionWhereInput
  >;
}

export interface EraSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EraWhereInput>;
  AND?: Maybe<EraSubscriptionWhereInput[] | EraSubscriptionWhereInput>;
  OR?: Maybe<EraSubscriptionWhereInput[] | EraSubscriptionWhereInput>;
  NOT?: Maybe<EraSubscriptionWhereInput[] | EraSubscriptionWhereInput>;
}

export interface ValidatorUpdateManyMutationInput {
  controller?: Maybe<String>;
  stash?: Maybe<String>;
  preferences?: Maybe<String>;
}

export interface BlockNumberCreateInput {
  id?: Maybe<ID_Input>;
  number: Int;
  authoredBy: String;
  startDateTime: DateTimeInput;
  hash: String;
}

export interface ValidatorCreateInput {
  id?: Maybe<ID_Input>;
  session: SessionCreateOneInput;
  controller: String;
  stash: String;
  preferences: String;
}

export interface BlockNumberUpdateInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<String>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export interface TotalIssuanceUpdateManyMutationInput {
  amount?: Maybe<String>;
}

export interface BlockNumberUpdateManyMutationInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<String>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export interface TotalIssuanceCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  amount: String;
}

export interface PreimageUpsertWithoutPreimageArgumentsInput {
  update: PreimageUpdateWithoutPreimageArgumentsDataInput;
  create: PreimageCreateWithoutPreimageArgumentsInput;
}

export interface StakeUpdateManyMutationInput {
  totalStake?: Maybe<String>;
}

export interface PreimageUpdateWithoutPreimageArgumentsDataInput {
  author?: Maybe<String>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  proposal?: Maybe<ProposalUpdateOneWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusUpdateManyWithoutPreimageInput>;
  section?: Maybe<String>;
}

export interface StakeCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  totalStake: String;
}

export interface EraCreateInput {
  id?: Maybe<ID_Input>;
  index: Int;
  eraStartSessionIndex: SessionCreateOneInput;
  totalPoints: String;
  individualPoints?: Maybe<EraCreateindividualPointsInput>;
}

export interface SlashingUpdateManyMutationInput {
  who?: Maybe<String>;
  amount?: Maybe<String>;
}

export interface SessionCreateOneInput {
  create?: Maybe<SessionCreateInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SlashingCreateInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  who: String;
  amount: String;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  index: Int;
  start: BlockNumberCreateOneInput;
}

export type ProposalArgumentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BlockNumberCreateOneInput {
  create?: Maybe<BlockNumberCreateInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface RewardUpdateManyMutationInput {
  amount?: Maybe<String>;
  recipients?: Maybe<RewardUpdaterecipientsInput>;
}

export interface EraCreateindividualPointsInput {
  set?: Maybe<String[] | String>;
}

export type RewardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EraUpdateInput {
  index?: Maybe<Int>;
  eraStartSessionIndex?: Maybe<SessionUpdateOneRequiredInput>;
  totalPoints?: Maybe<String>;
  individualPoints?: Maybe<EraUpdateindividualPointsInput>;
}

export interface RewardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  authoredBlock?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  OR?: Maybe<RewardWhereInput[] | RewardWhereInput>;
  NOT?: Maybe<RewardWhereInput[] | RewardWhereInput>;
}

export interface SessionUpdateOneRequiredInput {
  create?: Maybe<SessionCreateInput>;
  update?: Maybe<SessionUpdateDataInput>;
  upsert?: Maybe<SessionUpsertNestedInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface RewardCreateInput {
  id?: Maybe<ID_Input>;
  amount: String;
  authoredBlock: BlockNumberCreateOneInput;
  recipients?: Maybe<RewardCreaterecipientsInput>;
}

export interface SessionUpdateDataInput {
  index?: Maybe<Int>;
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface ProposalUpsertWithoutProposalArgumentsInput {
  update: ProposalUpdateWithoutProposalArgumentsDataInput;
  create: ProposalCreateWithoutProposalArgumentsInput;
}

export interface BlockNumberUpdateOneRequiredInput {
  create?: Maybe<BlockNumberCreateInput>;
  update?: Maybe<BlockNumberUpdateDataInput>;
  upsert?: Maybe<BlockNumberUpsertNestedInput>;
  connect?: Maybe<BlockNumberWhereUniqueInput>;
}

export interface ProposalUpdateWithoutProposalArgumentsDataInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  preimage?: Maybe<PreimageUpdateOneRequiredWithoutProposalInput>;
  proposal?: Maybe<String>;
  proposalId?: Maybe<Int>;
  proposer?: Maybe<String>;
  section?: Maybe<String>;
}

export interface BlockNumberUpdateDataInput {
  number?: Maybe<Int>;
  authoredBy?: Maybe<String>;
  startDateTime?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
}

export interface ProposalArgumentUpdateInput {
  name?: Maybe<String>;
  proposal?: Maybe<ProposalUpdateOneRequiredWithoutProposalArgumentsInput>;
  value?: Maybe<String>;
}

export interface BlockNumberUpsertNestedInput {
  update: BlockNumberUpdateDataInput;
  create: BlockNumberCreateInput;
}

export type SlashingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  who?: Maybe<String>;
}>;

export interface SessionUpsertNestedInput {
  update: SessionUpdateDataInput;
  create: SessionCreateInput;
}

export interface SlashingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  who?: Maybe<String>;
  who_not?: Maybe<String>;
  who_in?: Maybe<String[] | String>;
  who_not_in?: Maybe<String[] | String>;
  who_lt?: Maybe<String>;
  who_lte?: Maybe<String>;
  who_gt?: Maybe<String>;
  who_gte?: Maybe<String>;
  who_contains?: Maybe<String>;
  who_not_contains?: Maybe<String>;
  who_starts_with?: Maybe<String>;
  who_not_starts_with?: Maybe<String>;
  who_ends_with?: Maybe<String>;
  who_not_ends_with?: Maybe<String>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  AND?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  OR?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
  NOT?: Maybe<SlashingWhereInput[] | SlashingWhereInput>;
}

export interface EraUpdateindividualPointsInput {
  set?: Maybe<String[] | String>;
}

export interface ProposalArgumentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  proposal: ProposalCreateOneWithoutProposalArgumentsInput;
  value: String;
}

export interface EraUpdateManyMutationInput {
  index?: Maybe<Int>;
  totalPoints?: Maybe<String>;
  individualPoints?: Maybe<EraUpdateindividualPointsInput>;
}

export interface PreimageUpsertWithoutProposalInput {
  update: PreimageUpdateWithoutProposalDataInput;
  create: PreimageCreateWithoutProposalInput;
}

export interface NominationCreateInput {
  id?: Maybe<ID_Input>;
  validatorController: String;
  validatorStash: String;
  nominatorController: String;
  nominatorStash: String;
  session: SessionCreateOneInput;
  bonded: String;
}

export interface PreimageUpdateWithoutProposalDataInput {
  author?: Maybe<String>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  preimageArguments?: Maybe<PreimageArgumentUpdateManyWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusUpdateManyWithoutPreimageInput>;
  section?: Maybe<String>;
}

export interface NominationUpdateInput {
  validatorController?: Maybe<String>;
  validatorStash?: Maybe<String>;
  nominatorController?: Maybe<String>;
  nominatorStash?: Maybe<String>;
  session?: Maybe<SessionUpdateOneRequiredInput>;
  bonded?: Maybe<String>;
}

export interface PreimageUpdateOneRequiredWithoutProposalInput {
  create?: Maybe<PreimageCreateWithoutProposalInput>;
  update?: Maybe<PreimageUpdateWithoutProposalDataInput>;
  upsert?: Maybe<PreimageUpsertWithoutProposalInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface NominationUpdateManyMutationInput {
  validatorController?: Maybe<String>;
  validatorStash?: Maybe<String>;
  nominatorController?: Maybe<String>;
  nominatorStash?: Maybe<String>;
  bonded?: Maybe<String>;
}

export interface PreimageCreateWithoutProposalInput {
  id?: Maybe<ID_Input>;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  preimageArguments?: Maybe<PreimageArgumentCreateManyWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusCreateManyWithoutPreimageInput>;
  section: String;
}

export interface PreimageCreateInput {
  id?: Maybe<ID_Input>;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal?: Maybe<ProposalCreateOneWithoutPreimageInput>;
  preimageArguments?: Maybe<PreimageArgumentCreateManyWithoutPreimageInput>;
  preimageStatus?: Maybe<PreimageStatusCreateManyWithoutPreimageInput>;
  section: String;
}

export type TotalIssuanceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreimageUpdateOneRequiredWithoutPreimageArgumentsInput {
  create?: Maybe<PreimageCreateWithoutPreimageArgumentsInput>;
  update?: Maybe<PreimageUpdateWithoutPreimageArgumentsDataInput>;
  upsert?: Maybe<PreimageUpsertWithoutPreimageArgumentsInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface ValidatorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValidatorWhereInput>;
  AND?: Maybe<
    ValidatorSubscriptionWhereInput[] | ValidatorSubscriptionWhereInput
  >;
  OR?: Maybe<
    ValidatorSubscriptionWhereInput[] | ValidatorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ValidatorSubscriptionWhereInput[] | ValidatorSubscriptionWhereInput
  >;
}

export interface ProposalCreateWithoutPreimageInput {
  blockNumber: BlockNumberCreateOneInput;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal: String;
  proposalArguments?: Maybe<ProposalArgumentCreateManyWithoutProposalInput>;
  proposalId: Int;
  proposer: String;
  section: String;
}

export interface StakeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StakeWhereInput>;
  AND?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  OR?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
  NOT?: Maybe<StakeSubscriptionWhereInput[] | StakeSubscriptionWhereInput>;
}

export interface ProposalArgumentCreateManyWithoutProposalInput {
  create?: Maybe<
    | ProposalArgumentCreateWithoutProposalInput[]
    | ProposalArgumentCreateWithoutProposalInput
  >;
  connect?: Maybe<
    ProposalArgumentWhereUniqueInput[] | ProposalArgumentWhereUniqueInput
  >;
}

export type PreimageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProposalArgumentCreateWithoutProposalInput {
  id?: Maybe<ID_Input>;
  name: String;
  value: String;
}

export interface ProposalWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  depositAmount?: Maybe<String>;
  depositAmount_not?: Maybe<String>;
  depositAmount_in?: Maybe<String[] | String>;
  depositAmount_not_in?: Maybe<String[] | String>;
  depositAmount_lt?: Maybe<String>;
  depositAmount_lte?: Maybe<String>;
  depositAmount_gt?: Maybe<String>;
  depositAmount_gte?: Maybe<String>;
  depositAmount_contains?: Maybe<String>;
  depositAmount_not_contains?: Maybe<String>;
  depositAmount_starts_with?: Maybe<String>;
  depositAmount_not_starts_with?: Maybe<String>;
  depositAmount_ends_with?: Maybe<String>;
  depositAmount_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  metaDescription?: Maybe<String>;
  metaDescription_not?: Maybe<String>;
  metaDescription_in?: Maybe<String[] | String>;
  metaDescription_not_in?: Maybe<String[] | String>;
  metaDescription_lt?: Maybe<String>;
  metaDescription_lte?: Maybe<String>;
  metaDescription_gt?: Maybe<String>;
  metaDescription_gte?: Maybe<String>;
  metaDescription_contains?: Maybe<String>;
  metaDescription_not_contains?: Maybe<String>;
  metaDescription_starts_with?: Maybe<String>;
  metaDescription_not_starts_with?: Maybe<String>;
  metaDescription_ends_with?: Maybe<String>;
  metaDescription_not_ends_with?: Maybe<String>;
  method?: Maybe<String>;
  method_not?: Maybe<String>;
  method_in?: Maybe<String[] | String>;
  method_not_in?: Maybe<String[] | String>;
  method_lt?: Maybe<String>;
  method_lte?: Maybe<String>;
  method_gt?: Maybe<String>;
  method_gte?: Maybe<String>;
  method_contains?: Maybe<String>;
  method_not_contains?: Maybe<String>;
  method_starts_with?: Maybe<String>;
  method_not_starts_with?: Maybe<String>;
  method_ends_with?: Maybe<String>;
  method_not_ends_with?: Maybe<String>;
  preimage?: Maybe<PreimageWhereInput>;
  proposal?: Maybe<String>;
  proposal_not?: Maybe<String>;
  proposal_in?: Maybe<String[] | String>;
  proposal_not_in?: Maybe<String[] | String>;
  proposal_lt?: Maybe<String>;
  proposal_lte?: Maybe<String>;
  proposal_gt?: Maybe<String>;
  proposal_gte?: Maybe<String>;
  proposal_contains?: Maybe<String>;
  proposal_not_contains?: Maybe<String>;
  proposal_starts_with?: Maybe<String>;
  proposal_not_starts_with?: Maybe<String>;
  proposal_ends_with?: Maybe<String>;
  proposal_not_ends_with?: Maybe<String>;
  proposalArguments_every?: Maybe<ProposalArgumentWhereInput>;
  proposalArguments_some?: Maybe<ProposalArgumentWhereInput>;
  proposalArguments_none?: Maybe<ProposalArgumentWhereInput>;
  proposalId?: Maybe<Int>;
  proposalId_not?: Maybe<Int>;
  proposalId_in?: Maybe<Int[] | Int>;
  proposalId_not_in?: Maybe<Int[] | Int>;
  proposalId_lt?: Maybe<Int>;
  proposalId_lte?: Maybe<Int>;
  proposalId_gt?: Maybe<Int>;
  proposalId_gte?: Maybe<Int>;
  proposer?: Maybe<String>;
  proposer_not?: Maybe<String>;
  proposer_in?: Maybe<String[] | String>;
  proposer_not_in?: Maybe<String[] | String>;
  proposer_lt?: Maybe<String>;
  proposer_lte?: Maybe<String>;
  proposer_gt?: Maybe<String>;
  proposer_gte?: Maybe<String>;
  proposer_contains?: Maybe<String>;
  proposer_not_contains?: Maybe<String>;
  proposer_starts_with?: Maybe<String>;
  proposer_not_starts_with?: Maybe<String>;
  proposer_ends_with?: Maybe<String>;
  proposer_not_ends_with?: Maybe<String>;
  section?: Maybe<String>;
  section_not?: Maybe<String>;
  section_in?: Maybe<String[] | String>;
  section_not_in?: Maybe<String[] | String>;
  section_lt?: Maybe<String>;
  section_lte?: Maybe<String>;
  section_gt?: Maybe<String>;
  section_gte?: Maybe<String>;
  section_contains?: Maybe<String>;
  section_not_contains?: Maybe<String>;
  section_starts_with?: Maybe<String>;
  section_not_starts_with?: Maybe<String>;
  section_ends_with?: Maybe<String>;
  section_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
  OR?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
  NOT?: Maybe<ProposalWhereInput[] | ProposalWhereInput>;
}

export interface PreimageArgumentCreateManyWithoutPreimageInput {
  create?: Maybe<
    | PreimageArgumentCreateWithoutPreimageInput[]
    | PreimageArgumentCreateWithoutPreimageInput
  >;
  connect?: Maybe<
    PreimageArgumentWhereUniqueInput[] | PreimageArgumentWhereUniqueInput
  >;
}

export interface PreimageStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreimageStatusWhereInput>;
  AND?: Maybe<
    | PreimageStatusSubscriptionWhereInput[]
    | PreimageStatusSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PreimageStatusSubscriptionWhereInput[]
    | PreimageStatusSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PreimageStatusSubscriptionWhereInput[]
    | PreimageStatusSubscriptionWhereInput
  >;
}

export interface PreimageArgumentCreateWithoutPreimageInput {
  id?: Maybe<ID_Input>;
  name: String;
  value: String;
}

export interface NominationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NominationWhereInput>;
  AND?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NominationSubscriptionWhereInput[] | NominationSubscriptionWhereInput
  >;
}

export interface PreimageStatusCreateManyWithoutPreimageInput {
  create?: Maybe<
    | PreimageStatusCreateWithoutPreimageInput[]
    | PreimageStatusCreateWithoutPreimageInput
  >;
  connect?: Maybe<
    PreimageStatusWhereUniqueInput[] | PreimageStatusWhereUniqueInput
  >;
}

export interface ValidatorUpdateInput {
  session?: Maybe<SessionUpdateOneRequiredInput>;
  controller?: Maybe<String>;
  stash?: Maybe<String>;
  preferences?: Maybe<String>;
}

export interface PreimageStatusCreateWithoutPreimageInput {
  id?: Maybe<ID_Input>;
  blockNumber: BlockNumberCreateOneInput;
  status: String;
}

export interface TotalIssuanceUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  amount?: Maybe<String>;
}

export interface EraWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  eraStartSessionIndex?: Maybe<SessionWhereInput>;
  totalPoints?: Maybe<String>;
  totalPoints_not?: Maybe<String>;
  totalPoints_in?: Maybe<String[] | String>;
  totalPoints_not_in?: Maybe<String[] | String>;
  totalPoints_lt?: Maybe<String>;
  totalPoints_lte?: Maybe<String>;
  totalPoints_gt?: Maybe<String>;
  totalPoints_gte?: Maybe<String>;
  totalPoints_contains?: Maybe<String>;
  totalPoints_not_contains?: Maybe<String>;
  totalPoints_starts_with?: Maybe<String>;
  totalPoints_not_starts_with?: Maybe<String>;
  totalPoints_ends_with?: Maybe<String>;
  totalPoints_not_ends_with?: Maybe<String>;
  AND?: Maybe<EraWhereInput[] | EraWhereInput>;
  OR?: Maybe<EraWhereInput[] | EraWhereInput>;
  NOT?: Maybe<EraWhereInput[] | EraWhereInput>;
}

export interface StakeUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  totalStake?: Maybe<String>;
}

export interface PreimageArgumentUpdateInput {
  name?: Maybe<String>;
  preimage?: Maybe<PreimageUpdateOneRequiredWithoutPreimageArgumentsInput>;
  value?: Maybe<String>;
}

export interface SlashingUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  who?: Maybe<String>;
  amount?: Maybe<String>;
}

export interface ProposalUpdateWithoutPreimageDataInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  proposal?: Maybe<String>;
  proposalArguments?: Maybe<ProposalArgumentUpdateManyWithoutProposalInput>;
  proposalId?: Maybe<Int>;
  proposer?: Maybe<String>;
  section?: Maybe<String>;
}

export interface SessionUpdateInput {
  index?: Maybe<Int>;
  start?: Maybe<BlockNumberUpdateOneRequiredInput>;
}

export interface ProposalArgumentUpdateManyWithoutProposalInput {
  create?: Maybe<
    | ProposalArgumentCreateWithoutProposalInput[]
    | ProposalArgumentCreateWithoutProposalInput
  >;
  delete?: Maybe<
    ProposalArgumentWhereUniqueInput[] | ProposalArgumentWhereUniqueInput
  >;
  connect?: Maybe<
    ProposalArgumentWhereUniqueInput[] | ProposalArgumentWhereUniqueInput
  >;
  set?: Maybe<
    ProposalArgumentWhereUniqueInput[] | ProposalArgumentWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProposalArgumentWhereUniqueInput[] | ProposalArgumentWhereUniqueInput
  >;
  update?: Maybe<
    | ProposalArgumentUpdateWithWhereUniqueWithoutProposalInput[]
    | ProposalArgumentUpdateWithWhereUniqueWithoutProposalInput
  >;
  upsert?: Maybe<
    | ProposalArgumentUpsertWithWhereUniqueWithoutProposalInput[]
    | ProposalArgumentUpsertWithWhereUniqueWithoutProposalInput
  >;
  deleteMany?: Maybe<
    ProposalArgumentScalarWhereInput[] | ProposalArgumentScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProposalArgumentUpdateManyWithWhereNestedInput[]
    | ProposalArgumentUpdateManyWithWhereNestedInput
  >;
}

export interface RewardUpdateInput {
  amount?: Maybe<String>;
  authoredBlock?: Maybe<BlockNumberUpdateOneRequiredInput>;
  recipients?: Maybe<RewardUpdaterecipientsInput>;
}

export interface ProposalArgumentUpdateWithWhereUniqueWithoutProposalInput {
  where: ProposalArgumentWhereUniqueInput;
  data: ProposalArgumentUpdateWithoutProposalDataInput;
}

export interface ProposalArgumentUpdateManyMutationInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export interface ProposalArgumentUpdateWithoutProposalDataInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export interface ProposalUpdateOneRequiredWithoutProposalArgumentsInput {
  create?: Maybe<ProposalCreateWithoutProposalArgumentsInput>;
  update?: Maybe<ProposalUpdateWithoutProposalArgumentsDataInput>;
  upsert?: Maybe<ProposalUpsertWithoutProposalArgumentsInput>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export interface ProposalArgumentUpsertWithWhereUniqueWithoutProposalInput {
  where: ProposalArgumentWhereUniqueInput;
  update: ProposalArgumentUpdateWithoutProposalDataInput;
  create: ProposalArgumentCreateWithoutProposalInput;
}

export interface ProposalCreateOneWithoutProposalArgumentsInput {
  create?: Maybe<ProposalCreateWithoutProposalArgumentsInput>;
  connect?: Maybe<ProposalWhereUniqueInput>;
}

export interface ProposalArgumentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProposalArgumentScalarWhereInput[] | ProposalArgumentScalarWhereInput
  >;
  OR?: Maybe<
    ProposalArgumentScalarWhereInput[] | ProposalArgumentScalarWhereInput
  >;
  NOT?: Maybe<
    ProposalArgumentScalarWhereInput[] | ProposalArgumentScalarWhereInput
  >;
}

export interface ProposalUpdateManyMutationInput {
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  proposal?: Maybe<String>;
  proposalId?: Maybe<Int>;
  proposer?: Maybe<String>;
  section?: Maybe<String>;
}

export interface ProposalArgumentUpdateManyWithWhereNestedInput {
  where: ProposalArgumentScalarWhereInput;
  data: ProposalArgumentUpdateManyDataInput;
}

export interface StakeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blockNumber?: Maybe<BlockNumberWhereInput>;
  totalStake?: Maybe<String>;
  totalStake_not?: Maybe<String>;
  totalStake_in?: Maybe<String[] | String>;
  totalStake_not_in?: Maybe<String[] | String>;
  totalStake_lt?: Maybe<String>;
  totalStake_lte?: Maybe<String>;
  totalStake_gt?: Maybe<String>;
  totalStake_gte?: Maybe<String>;
  totalStake_contains?: Maybe<String>;
  totalStake_not_contains?: Maybe<String>;
  totalStake_starts_with?: Maybe<String>;
  totalStake_not_starts_with?: Maybe<String>;
  totalStake_ends_with?: Maybe<String>;
  totalStake_not_ends_with?: Maybe<String>;
  AND?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  OR?: Maybe<StakeWhereInput[] | StakeWhereInput>;
  NOT?: Maybe<StakeWhereInput[] | StakeWhereInput>;
}

export interface ProposalArgumentUpdateManyDataInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export interface PreimageCreateOneWithoutProposalInput {
  create?: Maybe<PreimageCreateWithoutProposalInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface ProposalUpsertWithoutPreimageInput {
  update: ProposalUpdateWithoutPreimageDataInput;
  create: ProposalCreateWithoutPreimageInput;
}

export interface TotalIssuanceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TotalIssuanceWhereInput>;
  AND?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  OR?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TotalIssuanceSubscriptionWhereInput[] | TotalIssuanceSubscriptionWhereInput
  >;
}

export interface PreimageArgumentUpdateManyWithoutPreimageInput {
  create?: Maybe<
    | PreimageArgumentCreateWithoutPreimageInput[]
    | PreimageArgumentCreateWithoutPreimageInput
  >;
  delete?: Maybe<
    PreimageArgumentWhereUniqueInput[] | PreimageArgumentWhereUniqueInput
  >;
  connect?: Maybe<
    PreimageArgumentWhereUniqueInput[] | PreimageArgumentWhereUniqueInput
  >;
  set?: Maybe<
    PreimageArgumentWhereUniqueInput[] | PreimageArgumentWhereUniqueInput
  >;
  disconnect?: Maybe<
    PreimageArgumentWhereUniqueInput[] | PreimageArgumentWhereUniqueInput
  >;
  update?: Maybe<
    | PreimageArgumentUpdateWithWhereUniqueWithoutPreimageInput[]
    | PreimageArgumentUpdateWithWhereUniqueWithoutPreimageInput
  >;
  upsert?: Maybe<
    | PreimageArgumentUpsertWithWhereUniqueWithoutPreimageInput[]
    | PreimageArgumentUpsertWithWhereUniqueWithoutPreimageInput
  >;
  deleteMany?: Maybe<
    PreimageArgumentScalarWhereInput[] | PreimageArgumentScalarWhereInput
  >;
  updateMany?: Maybe<
    | PreimageArgumentUpdateManyWithWhereNestedInput[]
    | PreimageArgumentUpdateManyWithWhereNestedInput
  >;
}

export interface ProposalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProposalWhereInput>;
  AND?: Maybe<
    ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput
  >;
  OR?: Maybe<ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput>;
  NOT?: Maybe<
    ProposalSubscriptionWhereInput[] | ProposalSubscriptionWhereInput
  >;
}

export interface PreimageArgumentUpdateWithWhereUniqueWithoutPreimageInput {
  where: PreimageArgumentWhereUniqueInput;
  data: PreimageArgumentUpdateWithoutPreimageDataInput;
}

export type EraWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  index?: Maybe<Int>;
}>;

export interface PreimageArgumentUpdateWithoutPreimageDataInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export type PreimageArgumentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreimageArgumentUpsertWithWhereUniqueWithoutPreimageInput {
  where: PreimageArgumentWhereUniqueInput;
  update: PreimageArgumentUpdateWithoutPreimageDataInput;
  create: PreimageArgumentCreateWithoutPreimageInput;
}

export type ProposalWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  proposalId?: Maybe<Int>;
}>;

export interface PreimageArgumentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PreimageArgumentScalarWhereInput[] | PreimageArgumentScalarWhereInput
  >;
  OR?: Maybe<
    PreimageArgumentScalarWhereInput[] | PreimageArgumentScalarWhereInput
  >;
  NOT?: Maybe<
    PreimageArgumentScalarWhereInput[] | PreimageArgumentScalarWhereInput
  >;
}

export interface RewardUpdaterecipientsInput {
  set?: Maybe<String[] | String>;
}

export interface PreimageArgumentUpdateManyWithWhereNestedInput {
  where: PreimageArgumentScalarWhereInput;
  data: PreimageArgumentUpdateManyDataInput;
}

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  index?: Maybe<Int>;
}>;

export interface PreimageArgumentUpdateManyDataInput {
  name?: Maybe<String>;
  value?: Maybe<String>;
}

export interface BlockNumberWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  authoredBy?: Maybe<String>;
  authoredBy_not?: Maybe<String>;
  authoredBy_in?: Maybe<String[] | String>;
  authoredBy_not_in?: Maybe<String[] | String>;
  authoredBy_lt?: Maybe<String>;
  authoredBy_lte?: Maybe<String>;
  authoredBy_gt?: Maybe<String>;
  authoredBy_gte?: Maybe<String>;
  authoredBy_contains?: Maybe<String>;
  authoredBy_not_contains?: Maybe<String>;
  authoredBy_starts_with?: Maybe<String>;
  authoredBy_not_starts_with?: Maybe<String>;
  authoredBy_ends_with?: Maybe<String>;
  authoredBy_not_ends_with?: Maybe<String>;
  startDateTime?: Maybe<DateTimeInput>;
  startDateTime_not?: Maybe<DateTimeInput>;
  startDateTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDateTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDateTime_lt?: Maybe<DateTimeInput>;
  startDateTime_lte?: Maybe<DateTimeInput>;
  startDateTime_gt?: Maybe<DateTimeInput>;
  startDateTime_gte?: Maybe<DateTimeInput>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  AND?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  OR?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
  NOT?: Maybe<BlockNumberWhereInput[] | BlockNumberWhereInput>;
}

export interface PreimageStatusUpdateManyWithoutPreimageInput {
  create?: Maybe<
    | PreimageStatusCreateWithoutPreimageInput[]
    | PreimageStatusCreateWithoutPreimageInput
  >;
  delete?: Maybe<
    PreimageStatusWhereUniqueInput[] | PreimageStatusWhereUniqueInput
  >;
  connect?: Maybe<
    PreimageStatusWhereUniqueInput[] | PreimageStatusWhereUniqueInput
  >;
  set?: Maybe<
    PreimageStatusWhereUniqueInput[] | PreimageStatusWhereUniqueInput
  >;
  disconnect?: Maybe<
    PreimageStatusWhereUniqueInput[] | PreimageStatusWhereUniqueInput
  >;
  update?: Maybe<
    | PreimageStatusUpdateWithWhereUniqueWithoutPreimageInput[]
    | PreimageStatusUpdateWithWhereUniqueWithoutPreimageInput
  >;
  upsert?: Maybe<
    | PreimageStatusUpsertWithWhereUniqueWithoutPreimageInput[]
    | PreimageStatusUpsertWithWhereUniqueWithoutPreimageInput
  >;
  deleteMany?: Maybe<
    PreimageStatusScalarWhereInput[] | PreimageStatusScalarWhereInput
  >;
  updateMany?: Maybe<
    | PreimageStatusUpdateManyWithWhereNestedInput[]
    | PreimageStatusUpdateManyWithWhereNestedInput
  >;
}

export interface ProposalUpdateInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  preimage?: Maybe<PreimageUpdateOneRequiredWithoutProposalInput>;
  proposal?: Maybe<String>;
  proposalArguments?: Maybe<ProposalArgumentUpdateManyWithoutProposalInput>;
  proposalId?: Maybe<Int>;
  proposer?: Maybe<String>;
  section?: Maybe<String>;
}

export interface PreimageStatusUpdateWithWhereUniqueWithoutPreimageInput {
  where: PreimageStatusWhereUniqueInput;
  data: PreimageStatusUpdateWithoutPreimageDataInput;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface PreimageStatusUpdateWithoutPreimageDataInput {
  blockNumber?: Maybe<BlockNumberUpdateOneRequiredInput>;
  status?: Maybe<String>;
}

export interface BlockNumberSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BlockNumberWhereInput>;
  AND?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  OR?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BlockNumberSubscriptionWhereInput[] | BlockNumberSubscriptionWhereInput
  >;
}

export interface PreimageStatusUpsertWithWhereUniqueWithoutPreimageInput {
  where: PreimageStatusWhereUniqueInput;
  update: PreimageStatusUpdateWithoutPreimageDataInput;
  create: PreimageStatusCreateWithoutPreimageInput;
}

export interface SessionUpdateManyMutationInput {
  index?: Maybe<Int>;
}

export interface PreimageStatusScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PreimageStatusScalarWhereInput[] | PreimageStatusScalarWhereInput
  >;
  OR?: Maybe<PreimageStatusScalarWhereInput[] | PreimageStatusScalarWhereInput>;
  NOT?: Maybe<
    PreimageStatusScalarWhereInput[] | PreimageStatusScalarWhereInput
  >;
}

export interface ProposalCreateWithoutProposalArgumentsInput {
  blockNumber: BlockNumberCreateOneInput;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  preimage: PreimageCreateOneWithoutProposalInput;
  proposal: String;
  proposalId: Int;
  proposer: String;
  section: String;
}

export interface PreimageStatusUpdateManyWithWhereNestedInput {
  where: PreimageStatusScalarWhereInput;
  data: PreimageStatusUpdateManyDataInput;
}

export interface ProposalCreateInput {
  blockNumber: BlockNumberCreateOneInput;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  preimage: PreimageCreateOneWithoutProposalInput;
  proposal: String;
  proposalArguments?: Maybe<ProposalArgumentCreateManyWithoutProposalInput>;
  proposalId: Int;
  proposer: String;
  section: String;
}

export interface PreimageCreateOneWithoutPreimageArgumentsInput {
  create?: Maybe<PreimageCreateWithoutPreimageArgumentsInput>;
  connect?: Maybe<PreimageWhereUniqueInput>;
}

export interface PreimageArgumentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  preimage: PreimageCreateOneWithoutPreimageArgumentsInput;
  value: String;
}

export interface PreimageUpdateManyMutationInput {
  author?: Maybe<String>;
  depositAmount?: Maybe<String>;
  hash?: Maybe<String>;
  metaDescription?: Maybe<String>;
  method?: Maybe<String>;
  section?: Maybe<String>;
}

export interface PreimageStatusUpdateManyDataInput {
  status?: Maybe<String>;
}

export interface PreimageArgumentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  preimage?: Maybe<PreimageWhereInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<PreimageArgumentWhereInput[] | PreimageArgumentWhereInput>;
  OR?: Maybe<PreimageArgumentWhereInput[] | PreimageArgumentWhereInput>;
  NOT?: Maybe<PreimageArgumentWhereInput[] | PreimageArgumentWhereInput>;
}

export type StakeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RewardCreaterecipientsInput {
  set?: Maybe<String[] | String>;
}

export type PreimageStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface ValidatorPreviousValues {
  id: ID_Output;
  controller: String;
  stash: String;
  preferences: String;
}

export interface ValidatorPreviousValuesPromise
  extends Promise<ValidatorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  controller: () => Promise<String>;
  stash: () => Promise<String>;
  preferences: () => Promise<String>;
}

export interface ValidatorPreviousValuesSubscription
  extends Promise<AsyncIterator<ValidatorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  controller: () => Promise<AsyncIterator<String>>;
  stash: () => Promise<AsyncIterator<String>>;
  preferences: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePreimage {
  count: Int;
}

export interface AggregatePreimagePromise
  extends Promise<AggregatePreimage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreimageSubscription
  extends Promise<AsyncIterator<AggregatePreimage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EraConnection {
  pageInfo: PageInfo;
  edges: EraEdge[];
}

export interface EraConnectionPromise
  extends Promise<EraConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EraEdge>>() => T;
  aggregate: <T = AggregateEraPromise>() => T;
}

export interface EraConnectionSubscription
  extends Promise<AsyncIterator<EraConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EraEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEraSubscription>() => T;
}

export interface PreimageEdge {
  node: Preimage;
  cursor: String;
}

export interface PreimageEdgePromise
  extends Promise<PreimageEdge>,
    Fragmentable {
  node: <T = PreimagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreimageEdgeSubscription
  extends Promise<AsyncIterator<PreimageEdge>>,
    Fragmentable {
  node: <T = PreimageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EraEdge {
  node: Era;
  cursor: String;
}

export interface EraEdgePromise extends Promise<EraEdge>, Fragmentable {
  node: <T = EraPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EraEdgeSubscription
  extends Promise<AsyncIterator<EraEdge>>,
    Fragmentable {
  node: <T = EraSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PreimageConnection {
  pageInfo: PageInfo;
  edges: PreimageEdge[];
}

export interface PreimageConnectionPromise
  extends Promise<PreimageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreimageEdge>>() => T;
  aggregate: <T = AggregatePreimagePromise>() => T;
}

export interface PreimageConnectionSubscription
  extends Promise<AsyncIterator<PreimageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreimageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreimageSubscription>() => T;
}

export interface AggregateValidator {
  count: Int;
}

export interface AggregateValidatorPromise
  extends Promise<AggregateValidator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValidatorSubscription
  extends Promise<AsyncIterator<AggregateValidator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BlockNumberEdge {
  node: BlockNumber;
  cursor: String;
}

export interface BlockNumberEdgePromise
  extends Promise<BlockNumberEdge>,
    Fragmentable {
  node: <T = BlockNumberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BlockNumberEdgeSubscription
  extends Promise<AsyncIterator<BlockNumberEdge>>,
    Fragmentable {
  node: <T = BlockNumberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ValidatorConnection {
  pageInfo: PageInfo;
  edges: ValidatorEdge[];
}

export interface ValidatorConnectionPromise
  extends Promise<ValidatorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValidatorEdge>>() => T;
  aggregate: <T = AggregateValidatorPromise>() => T;
}

export interface ValidatorConnectionSubscription
  extends Promise<AsyncIterator<ValidatorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValidatorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValidatorSubscription>() => T;
}

export interface ValidatorEdge {
  node: Validator;
  cursor: String;
}

export interface ValidatorEdgePromise
  extends Promise<ValidatorEdge>,
    Fragmentable {
  node: <T = ValidatorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValidatorEdgeSubscription
  extends Promise<AsyncIterator<ValidatorEdge>>,
    Fragmentable {
  node: <T = ValidatorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Nomination {
  id: ID_Output;
  validatorController: String;
  validatorStash: String;
  nominatorController: String;
  nominatorStash: String;
  bonded: String;
}

export interface NominationPromise extends Promise<Nomination>, Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<String>;
  validatorStash: () => Promise<String>;
  nominatorController: () => Promise<String>;
  nominatorStash: () => Promise<String>;
  session: <T = SessionPromise>() => T;
  bonded: () => Promise<String>;
}

export interface NominationSubscription
  extends Promise<AsyncIterator<Nomination>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validatorController: () => Promise<AsyncIterator<String>>;
  validatorStash: () => Promise<AsyncIterator<String>>;
  nominatorController: () => Promise<AsyncIterator<String>>;
  nominatorStash: () => Promise<AsyncIterator<String>>;
  session: <T = SessionSubscription>() => T;
  bonded: () => Promise<AsyncIterator<String>>;
}

export interface NominationNullablePromise
  extends Promise<Nomination | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<String>;
  validatorStash: () => Promise<String>;
  nominatorController: () => Promise<String>;
  nominatorStash: () => Promise<String>;
  session: <T = SessionPromise>() => T;
  bonded: () => Promise<String>;
}

export interface TotalIssuanceSubscriptionPayload {
  mutation: MutationType;
  node: TotalIssuance;
  updatedFields: String[];
  previousValues: TotalIssuancePreviousValues;
}

export interface TotalIssuanceSubscriptionPayloadPromise
  extends Promise<TotalIssuanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TotalIssuancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TotalIssuancePreviousValuesPromise>() => T;
}

export interface TotalIssuanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TotalIssuanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TotalIssuanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TotalIssuancePreviousValuesSubscription>() => T;
}

export interface Validator {
  id: ID_Output;
  controller: String;
  stash: String;
  preferences: String;
}

export interface ValidatorPromise extends Promise<Validator>, Fragmentable {
  id: () => Promise<ID_Output>;
  session: <T = SessionPromise>() => T;
  controller: () => Promise<String>;
  stash: () => Promise<String>;
  preferences: () => Promise<String>;
}

export interface ValidatorSubscription
  extends Promise<AsyncIterator<Validator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  session: <T = SessionSubscription>() => T;
  controller: () => Promise<AsyncIterator<String>>;
  stash: () => Promise<AsyncIterator<String>>;
  preferences: () => Promise<AsyncIterator<String>>;
}

export interface ValidatorNullablePromise
  extends Promise<Validator | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  session: <T = SessionPromise>() => T;
  controller: () => Promise<String>;
  stash: () => Promise<String>;
  preferences: () => Promise<String>;
}

export interface AggregateTotalIssuance {
  count: Int;
}

export interface AggregateTotalIssuancePromise
  extends Promise<AggregateTotalIssuance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTotalIssuanceSubscription
  extends Promise<AsyncIterator<AggregateTotalIssuance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TotalIssuanceConnection {
  pageInfo: PageInfo;
  edges: TotalIssuanceEdge[];
}

export interface TotalIssuanceConnectionPromise
  extends Promise<TotalIssuanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TotalIssuanceEdge>>() => T;
  aggregate: <T = AggregateTotalIssuancePromise>() => T;
}

export interface TotalIssuanceConnectionSubscription
  extends Promise<AsyncIterator<TotalIssuanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TotalIssuanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTotalIssuanceSubscription>() => T;
}

export interface BlockNumberSubscriptionPayload {
  mutation: MutationType;
  node: BlockNumber;
  updatedFields: String[];
  previousValues: BlockNumberPreviousValues;
}

export interface BlockNumberSubscriptionPayloadPromise
  extends Promise<BlockNumberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BlockNumberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BlockNumberPreviousValuesPromise>() => T;
}

export interface BlockNumberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BlockNumberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BlockNumberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BlockNumberPreviousValuesSubscription>() => T;
}

export interface TotalIssuance {
  id: ID_Output;
  amount: String;
}

export interface TotalIssuancePromise
  extends Promise<TotalIssuance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  amount: () => Promise<String>;
}

export interface TotalIssuanceSubscription
  extends Promise<AsyncIterator<TotalIssuance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface TotalIssuanceNullablePromise
  extends Promise<TotalIssuance | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  amount: () => Promise<String>;
}

export interface BlockNumberPreviousValues {
  id: ID_Output;
  number: Int;
  authoredBy: String;
  startDateTime: DateTimeOutput;
  hash: String;
}

export interface BlockNumberPreviousValuesPromise
  extends Promise<BlockNumberPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<String>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface BlockNumberPreviousValuesSubscription
  extends Promise<AsyncIterator<BlockNumberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  authoredBy: () => Promise<AsyncIterator<String>>;
  startDateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface StakeEdge {
  node: Stake;
  cursor: String;
}

export interface StakeEdgePromise extends Promise<StakeEdge>, Fragmentable {
  node: <T = StakePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StakeEdgeSubscription
  extends Promise<AsyncIterator<StakeEdge>>,
    Fragmentable {
  node: <T = StakeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PreimageStatus {
  id: ID_Output;
  status: String;
}

export interface PreimageStatusPromise
  extends Promise<PreimageStatus>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  preimage: <T = PreimagePromise>() => T;
  status: () => Promise<String>;
}

export interface PreimageStatusSubscription
  extends Promise<AsyncIterator<PreimageStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  preimage: <T = PreimageSubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface PreimageStatusNullablePromise
  extends Promise<PreimageStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  preimage: <T = PreimagePromise>() => T;
  status: () => Promise<String>;
}

export interface ValidatorSubscriptionPayload {
  mutation: MutationType;
  node: Validator;
  updatedFields: String[];
  previousValues: ValidatorPreviousValues;
}

export interface ValidatorSubscriptionPayloadPromise
  extends Promise<ValidatorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValidatorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValidatorPreviousValuesPromise>() => T;
}

export interface ValidatorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValidatorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValidatorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValidatorPreviousValuesSubscription>() => T;
}

export interface EraSubscriptionPayload {
  mutation: MutationType;
  node: Era;
  updatedFields: String[];
  previousValues: EraPreviousValues;
}

export interface EraSubscriptionPayloadPromise
  extends Promise<EraSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EraPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EraPreviousValuesPromise>() => T;
}

export interface EraSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EraSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EraSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EraPreviousValuesSubscription>() => T;
}

export interface AggregateSlashing {
  count: Int;
}

export interface AggregateSlashingPromise
  extends Promise<AggregateSlashing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSlashingSubscription
  extends Promise<AsyncIterator<AggregateSlashing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EraPreviousValues {
  id: ID_Output;
  index: Int;
  totalPoints: String;
  individualPoints: String[];
}

export interface EraPreviousValuesPromise
  extends Promise<EraPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  totalPoints: () => Promise<String>;
  individualPoints: () => Promise<String[]>;
}

export interface EraPreviousValuesSubscription
  extends Promise<AsyncIterator<EraPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  totalPoints: () => Promise<AsyncIterator<String>>;
  individualPoints: () => Promise<AsyncIterator<String[]>>;
}

export interface SlashingConnection {
  pageInfo: PageInfo;
  edges: SlashingEdge[];
}

export interface SlashingConnectionPromise
  extends Promise<SlashingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SlashingEdge>>() => T;
  aggregate: <T = AggregateSlashingPromise>() => T;
}

export interface SlashingConnectionSubscription
  extends Promise<AsyncIterator<SlashingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SlashingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSlashingSubscription>() => T;
}

export interface AggregateBlockNumber {
  count: Int;
}

export interface AggregateBlockNumberPromise
  extends Promise<AggregateBlockNumber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBlockNumberSubscription
  extends Promise<AsyncIterator<AggregateBlockNumber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationSubscriptionPayload {
  mutation: MutationType;
  node: Nomination;
  updatedFields: String[];
  previousValues: NominationPreviousValues;
}

export interface NominationSubscriptionPayloadPromise
  extends Promise<NominationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NominationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NominationPreviousValuesPromise>() => T;
}

export interface NominationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NominationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NominationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NominationPreviousValuesSubscription>() => T;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface NominationPreviousValues {
  id: ID_Output;
  validatorController: String;
  validatorStash: String;
  nominatorController: String;
  nominatorStash: String;
  bonded: String;
}

export interface NominationPreviousValuesPromise
  extends Promise<NominationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  validatorController: () => Promise<String>;
  validatorStash: () => Promise<String>;
  nominatorController: () => Promise<String>;
  nominatorStash: () => Promise<String>;
  bonded: () => Promise<String>;
}

export interface NominationPreviousValuesSubscription
  extends Promise<AsyncIterator<NominationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  validatorController: () => Promise<AsyncIterator<String>>;
  validatorStash: () => Promise<AsyncIterator<String>>;
  nominatorController: () => Promise<AsyncIterator<String>>;
  nominatorStash: () => Promise<AsyncIterator<String>>;
  bonded: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReward {
  count: Int;
}

export interface AggregateRewardPromise
  extends Promise<AggregateReward>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRewardSubscription
  extends Promise<AsyncIterator<AggregateReward>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PreimageArgument {
  id: ID_Output;
  name: String;
  value: String;
}

export interface PreimageArgumentPromise
  extends Promise<PreimageArgument>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  preimage: <T = PreimagePromise>() => T;
  value: () => Promise<String>;
}

export interface PreimageArgumentSubscription
  extends Promise<AsyncIterator<PreimageArgument>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  preimage: <T = PreimageSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface PreimageArgumentNullablePromise
  extends Promise<PreimageArgument | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  preimage: <T = PreimagePromise>() => T;
  value: () => Promise<String>;
}

export interface RewardConnection {
  pageInfo: PageInfo;
  edges: RewardEdge[];
}

export interface RewardConnectionPromise
  extends Promise<RewardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RewardEdge>>() => T;
  aggregate: <T = AggregateRewardPromise>() => T;
}

export interface RewardConnectionSubscription
  extends Promise<AsyncIterator<RewardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RewardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRewardSubscription>() => T;
}

export interface PreimageSubscriptionPayload {
  mutation: MutationType;
  node: Preimage;
  updatedFields: String[];
  previousValues: PreimagePreviousValues;
}

export interface PreimageSubscriptionPayloadPromise
  extends Promise<PreimageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreimagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreimagePreviousValuesPromise>() => T;
}

export interface PreimageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreimageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreimageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreimagePreviousValuesSubscription>() => T;
}

export interface Reward {
  id: ID_Output;
  amount: String;
  recipients: String[];
}

export interface RewardPromise extends Promise<Reward>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  authoredBlock: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<String[]>;
}

export interface RewardSubscription
  extends Promise<AsyncIterator<Reward>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  authoredBlock: <T = BlockNumberSubscription>() => T;
  recipients: () => Promise<AsyncIterator<String[]>>;
}

export interface RewardNullablePromise
  extends Promise<Reward | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  authoredBlock: <T = BlockNumberPromise>() => T;
  recipients: () => Promise<String[]>;
}

export interface PreimagePreviousValues {
  id: ID_Output;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  section: String;
}

export interface PreimagePreviousValuesPromise
  extends Promise<PreimagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  author: () => Promise<String>;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  section: () => Promise<String>;
}

export interface PreimagePreviousValuesSubscription
  extends Promise<AsyncIterator<PreimagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: () => Promise<AsyncIterator<String>>;
  depositAmount: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  method: () => Promise<AsyncIterator<String>>;
  section: () => Promise<AsyncIterator<String>>;
}

export interface ProposalArgumentEdge {
  node: ProposalArgument;
  cursor: String;
}

export interface ProposalArgumentEdgePromise
  extends Promise<ProposalArgumentEdge>,
    Fragmentable {
  node: <T = ProposalArgumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProposalArgumentEdgeSubscription
  extends Promise<AsyncIterator<ProposalArgumentEdge>>,
    Fragmentable {
  node: <T = ProposalArgumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProposalArgument {
  id: ID_Output;
  name: String;
  value: String;
}

export interface ProposalArgumentPromise
  extends Promise<ProposalArgument>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  proposal: <T = ProposalPromise>() => T;
  value: () => Promise<String>;
}

export interface ProposalArgumentSubscription
  extends Promise<AsyncIterator<ProposalArgument>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  proposal: <T = ProposalSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ProposalArgumentNullablePromise
  extends Promise<ProposalArgument | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  proposal: <T = ProposalPromise>() => T;
  value: () => Promise<String>;
}

export interface AggregateProposal {
  count: Int;
}

export interface AggregateProposalPromise
  extends Promise<AggregateProposal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProposalSubscription
  extends Promise<AsyncIterator<AggregateProposal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PreimageArgumentSubscriptionPayload {
  mutation: MutationType;
  node: PreimageArgument;
  updatedFields: String[];
  previousValues: PreimageArgumentPreviousValues;
}

export interface PreimageArgumentSubscriptionPayloadPromise
  extends Promise<PreimageArgumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreimageArgumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreimageArgumentPreviousValuesPromise>() => T;
}

export interface PreimageArgumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreimageArgumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreimageArgumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreimageArgumentPreviousValuesSubscription>() => T;
}

export interface ProposalConnection {
  pageInfo: PageInfo;
  edges: ProposalEdge[];
}

export interface ProposalConnectionPromise
  extends Promise<ProposalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProposalEdge>>() => T;
  aggregate: <T = AggregateProposalPromise>() => T;
}

export interface ProposalConnectionSubscription
  extends Promise<AsyncIterator<ProposalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProposalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProposalSubscription>() => T;
}

export interface PreimageArgumentPreviousValues {
  id: ID_Output;
  name: String;
  value: String;
}

export interface PreimageArgumentPreviousValuesPromise
  extends Promise<PreimageArgumentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
}

export interface PreimageArgumentPreviousValuesSubscription
  extends Promise<AsyncIterator<PreimageArgumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePreimageStatus {
  count: Int;
}

export interface AggregatePreimageStatusPromise
  extends Promise<AggregatePreimageStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreimageStatusSubscription
  extends Promise<AsyncIterator<AggregatePreimageStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Era {
  id: ID_Output;
  index: Int;
  totalPoints: String;
  individualPoints: String[];
}

export interface EraPromise extends Promise<Era>, Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  eraStartSessionIndex: <T = SessionPromise>() => T;
  totalPoints: () => Promise<String>;
  individualPoints: () => Promise<String[]>;
}

export interface EraSubscription
  extends Promise<AsyncIterator<Era>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  eraStartSessionIndex: <T = SessionSubscription>() => T;
  totalPoints: () => Promise<AsyncIterator<String>>;
  individualPoints: () => Promise<AsyncIterator<String[]>>;
}

export interface EraNullablePromise extends Promise<Era | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  eraStartSessionIndex: <T = SessionPromise>() => T;
  totalPoints: () => Promise<String>;
  individualPoints: () => Promise<String[]>;
}

export interface PreimageStatusConnection {
  pageInfo: PageInfo;
  edges: PreimageStatusEdge[];
}

export interface PreimageStatusConnectionPromise
  extends Promise<PreimageStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreimageStatusEdge>>() => T;
  aggregate: <T = AggregatePreimageStatusPromise>() => T;
}

export interface PreimageStatusConnectionSubscription
  extends Promise<AsyncIterator<PreimageStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreimageStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreimageStatusSubscription>() => T;
}

export interface PreimageStatusSubscriptionPayload {
  mutation: MutationType;
  node: PreimageStatus;
  updatedFields: String[];
  previousValues: PreimageStatusPreviousValues;
}

export interface PreimageStatusSubscriptionPayloadPromise
  extends Promise<PreimageStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreimageStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreimageStatusPreviousValuesPromise>() => T;
}

export interface PreimageStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreimageStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreimageStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreimageStatusPreviousValuesSubscription>() => T;
}

export interface PreimageArgumentEdge {
  node: PreimageArgument;
  cursor: String;
}

export interface PreimageArgumentEdgePromise
  extends Promise<PreimageArgumentEdge>,
    Fragmentable {
  node: <T = PreimageArgumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreimageArgumentEdgeSubscription
  extends Promise<AsyncIterator<PreimageArgumentEdge>>,
    Fragmentable {
  node: <T = PreimageArgumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PreimageStatusPreviousValues {
  id: ID_Output;
  status: String;
}

export interface PreimageStatusPreviousValuesPromise
  extends Promise<PreimageStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
}

export interface PreimageStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<PreimageStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface TotalIssuancePreviousValues {
  id: ID_Output;
  amount: String;
}

export interface TotalIssuancePreviousValuesPromise
  extends Promise<TotalIssuancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
}

export interface TotalIssuancePreviousValuesSubscription
  extends Promise<AsyncIterator<TotalIssuancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface Proposal {
  id: Int;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal: String;
  proposalId: Int;
  proposer: String;
  section: String;
}

export interface ProposalPromise extends Promise<Proposal>, Fragmentable {
  id: () => Promise<Int>;
  blockNumber: <T = BlockNumberPromise>() => T;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  preimage: <T = PreimagePromise>() => T;
  proposal: () => Promise<String>;
  proposalArguments: <T = FragmentableArray<ProposalArgument>>(args?: {
    where?: ProposalArgumentWhereInput;
    orderBy?: ProposalArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  proposalId: () => Promise<Int>;
  proposer: () => Promise<String>;
  section: () => Promise<String>;
}

export interface ProposalSubscription
  extends Promise<AsyncIterator<Proposal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  depositAmount: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  method: () => Promise<AsyncIterator<String>>;
  preimage: <T = PreimageSubscription>() => T;
  proposal: () => Promise<AsyncIterator<String>>;
  proposalArguments: <
    T = Promise<AsyncIterator<ProposalArgumentSubscription>>
  >(args?: {
    where?: ProposalArgumentWhereInput;
    orderBy?: ProposalArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  proposalId: () => Promise<AsyncIterator<Int>>;
  proposer: () => Promise<AsyncIterator<String>>;
  section: () => Promise<AsyncIterator<String>>;
}

export interface ProposalNullablePromise
  extends Promise<Proposal | null>,
    Fragmentable {
  id: () => Promise<Int>;
  blockNumber: <T = BlockNumberPromise>() => T;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  preimage: <T = PreimagePromise>() => T;
  proposal: () => Promise<String>;
  proposalArguments: <T = FragmentableArray<ProposalArgument>>(args?: {
    where?: ProposalArgumentWhereInput;
    orderBy?: ProposalArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  proposalId: () => Promise<Int>;
  proposer: () => Promise<String>;
  section: () => Promise<String>;
}

export interface TotalIssuanceEdge {
  node: TotalIssuance;
  cursor: String;
}

export interface TotalIssuanceEdgePromise
  extends Promise<TotalIssuanceEdge>,
    Fragmentable {
  node: <T = TotalIssuancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TotalIssuanceEdgeSubscription
  extends Promise<AsyncIterator<TotalIssuanceEdge>>,
    Fragmentable {
  node: <T = TotalIssuanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProposalSubscriptionPayload {
  mutation: MutationType;
  node: Proposal;
  updatedFields: String[];
  previousValues: ProposalPreviousValues;
}

export interface ProposalSubscriptionPayloadPromise
  extends Promise<ProposalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProposalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProposalPreviousValuesPromise>() => T;
}

export interface ProposalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProposalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProposalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProposalPreviousValuesSubscription>() => T;
}

export interface AggregateStake {
  count: Int;
}

export interface AggregateStakePromise
  extends Promise<AggregateStake>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStakeSubscription
  extends Promise<AsyncIterator<AggregateStake>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProposalPreviousValues {
  id: Int;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  proposal: String;
  proposalId: Int;
  proposer: String;
  section: String;
}

export interface ProposalPreviousValuesPromise
  extends Promise<ProposalPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  proposal: () => Promise<String>;
  proposalId: () => Promise<Int>;
  proposer: () => Promise<String>;
  section: () => Promise<String>;
}

export interface ProposalPreviousValuesSubscription
  extends Promise<AsyncIterator<ProposalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  depositAmount: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  method: () => Promise<AsyncIterator<String>>;
  proposal: () => Promise<AsyncIterator<String>>;
  proposalId: () => Promise<AsyncIterator<Int>>;
  proposer: () => Promise<AsyncIterator<String>>;
  section: () => Promise<AsyncIterator<String>>;
}

export interface Stake {
  id: ID_Output;
  totalStake: String;
}

export interface StakePromise extends Promise<Stake>, Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  totalStake: () => Promise<String>;
}

export interface StakeSubscription
  extends Promise<AsyncIterator<Stake>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  totalStake: () => Promise<AsyncIterator<String>>;
}

export interface StakeNullablePromise
  extends Promise<Stake | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  totalStake: () => Promise<String>;
}

export interface Preimage {
  id: ID_Output;
  author: String;
  depositAmount: String;
  hash: String;
  metaDescription: String;
  method: String;
  section: String;
}

export interface PreimagePromise extends Promise<Preimage>, Fragmentable {
  id: () => Promise<ID_Output>;
  author: () => Promise<String>;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  proposal: <T = ProposalPromise>() => T;
  preimageArguments: <T = FragmentableArray<PreimageArgument>>(args?: {
    where?: PreimageArgumentWhereInput;
    orderBy?: PreimageArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preimageStatus: <T = FragmentableArray<PreimageStatus>>(args?: {
    where?: PreimageStatusWhereInput;
    orderBy?: PreimageStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  section: () => Promise<String>;
}

export interface PreimageSubscription
  extends Promise<AsyncIterator<Preimage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: () => Promise<AsyncIterator<String>>;
  depositAmount: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  method: () => Promise<AsyncIterator<String>>;
  proposal: <T = ProposalSubscription>() => T;
  preimageArguments: <
    T = Promise<AsyncIterator<PreimageArgumentSubscription>>
  >(args?: {
    where?: PreimageArgumentWhereInput;
    orderBy?: PreimageArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preimageStatus: <
    T = Promise<AsyncIterator<PreimageStatusSubscription>>
  >(args?: {
    where?: PreimageStatusWhereInput;
    orderBy?: PreimageStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  section: () => Promise<AsyncIterator<String>>;
}

export interface PreimageNullablePromise
  extends Promise<Preimage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  author: () => Promise<String>;
  depositAmount: () => Promise<String>;
  hash: () => Promise<String>;
  metaDescription: () => Promise<String>;
  method: () => Promise<String>;
  proposal: <T = ProposalPromise>() => T;
  preimageArguments: <T = FragmentableArray<PreimageArgument>>(args?: {
    where?: PreimageArgumentWhereInput;
    orderBy?: PreimageArgumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preimageStatus: <T = FragmentableArray<PreimageStatus>>(args?: {
    where?: PreimageStatusWhereInput;
    orderBy?: PreimageStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  section: () => Promise<String>;
}

export interface Slashing {
  id: ID_Output;
  who: String;
  amount: String;
}

export interface SlashingPromise extends Promise<Slashing>, Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  who: () => Promise<String>;
  amount: () => Promise<String>;
}

export interface SlashingSubscription
  extends Promise<AsyncIterator<Slashing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blockNumber: <T = BlockNumberSubscription>() => T;
  who: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface SlashingNullablePromise
  extends Promise<Slashing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blockNumber: <T = BlockNumberPromise>() => T;
  who: () => Promise<String>;
  amount: () => Promise<String>;
}

export interface ProposalArgumentSubscriptionPayload {
  mutation: MutationType;
  node: ProposalArgument;
  updatedFields: String[];
  previousValues: ProposalArgumentPreviousValues;
}

export interface ProposalArgumentSubscriptionPayloadPromise
  extends Promise<ProposalArgumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProposalArgumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProposalArgumentPreviousValuesPromise>() => T;
}

export interface ProposalArgumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProposalArgumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProposalArgumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProposalArgumentPreviousValuesSubscription>() => T;
}

export interface BlockNumberConnection {
  pageInfo: PageInfo;
  edges: BlockNumberEdge[];
}

export interface BlockNumberConnectionPromise
  extends Promise<BlockNumberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BlockNumberEdge>>() => T;
  aggregate: <T = AggregateBlockNumberPromise>() => T;
}

export interface BlockNumberConnectionSubscription
  extends Promise<AsyncIterator<BlockNumberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BlockNumberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBlockNumberSubscription>() => T;
}

export interface ProposalArgumentPreviousValues {
  id: ID_Output;
  name: String;
  value: String;
}

export interface ProposalArgumentPreviousValuesPromise
  extends Promise<ProposalArgumentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ProposalArgumentPreviousValuesSubscription
  extends Promise<AsyncIterator<ProposalArgumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNomination {
  count: Int;
}

export interface AggregateNominationPromise
  extends Promise<AggregateNomination>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNominationSubscription
  extends Promise<AsyncIterator<AggregateNomination>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProposalArgumentConnection {
  pageInfo: PageInfo;
  edges: ProposalArgumentEdge[];
}

export interface ProposalArgumentConnectionPromise
  extends Promise<ProposalArgumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProposalArgumentEdge>>() => T;
  aggregate: <T = AggregateProposalArgumentPromise>() => T;
}

export interface ProposalArgumentConnectionSubscription
  extends Promise<AsyncIterator<ProposalArgumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProposalArgumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProposalArgumentSubscription>() => T;
}

export interface RewardSubscriptionPayload {
  mutation: MutationType;
  node: Reward;
  updatedFields: String[];
  previousValues: RewardPreviousValues;
}

export interface RewardSubscriptionPayloadPromise
  extends Promise<RewardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RewardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RewardPreviousValuesPromise>() => T;
}

export interface RewardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RewardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RewardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RewardPreviousValuesSubscription>() => T;
}

export interface AggregateEra {
  count: Int;
}

export interface AggregateEraPromise
  extends Promise<AggregateEra>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEraSubscription
  extends Promise<AsyncIterator<AggregateEra>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RewardPreviousValues {
  id: ID_Output;
  amount: String;
  recipients: String[];
}

export interface RewardPreviousValuesPromise
  extends Promise<RewardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  recipients: () => Promise<String[]>;
}

export interface RewardPreviousValuesSubscription
  extends Promise<AsyncIterator<RewardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  recipients: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregatePreimageArgument {
  count: Int;
}

export interface AggregatePreimageArgumentPromise
  extends Promise<AggregatePreimageArgument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreimageArgumentSubscription
  extends Promise<AsyncIterator<AggregatePreimageArgument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NominationEdge {
  node: Nomination;
  cursor: String;
}

export interface NominationEdgePromise
  extends Promise<NominationEdge>,
    Fragmentable {
  node: <T = NominationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NominationEdgeSubscription
  extends Promise<AsyncIterator<NominationEdge>>,
    Fragmentable {
  node: <T = NominationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface StakeConnection {
  pageInfo: PageInfo;
  edges: StakeEdge[];
}

export interface StakeConnectionPromise
  extends Promise<StakeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StakeEdge>>() => T;
  aggregate: <T = AggregateStakePromise>() => T;
}

export interface StakeConnectionSubscription
  extends Promise<AsyncIterator<StakeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StakeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStakeSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  index: Int;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NominationConnection {
  pageInfo: PageInfo;
  edges: NominationEdge[];
}

export interface NominationConnectionPromise
  extends Promise<NominationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NominationEdge>>() => T;
  aggregate: <T = AggregateNominationPromise>() => T;
}

export interface NominationConnectionSubscription
  extends Promise<AsyncIterator<NominationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NominationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNominationSubscription>() => T;
}

export interface AggregateProposalArgument {
  count: Int;
}

export interface AggregateProposalArgumentPromise
  extends Promise<AggregateProposalArgument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProposalArgumentSubscription
  extends Promise<AsyncIterator<AggregateProposalArgument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SlashingSubscriptionPayload {
  mutation: MutationType;
  node: Slashing;
  updatedFields: String[];
  previousValues: SlashingPreviousValues;
}

export interface SlashingSubscriptionPayloadPromise
  extends Promise<SlashingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SlashingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SlashingPreviousValuesPromise>() => T;
}

export interface SlashingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SlashingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SlashingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SlashingPreviousValuesSubscription>() => T;
}

export interface PreimageStatusEdge {
  node: PreimageStatus;
  cursor: String;
}

export interface PreimageStatusEdgePromise
  extends Promise<PreimageStatusEdge>,
    Fragmentable {
  node: <T = PreimageStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreimageStatusEdgeSubscription
  extends Promise<AsyncIterator<PreimageStatusEdge>>,
    Fragmentable {
  node: <T = PreimageStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BlockNumber {
  id: ID_Output;
  number: Int;
  authoredBy: String;
  startDateTime: DateTimeOutput;
  hash: String;
}

export interface BlockNumberPromise extends Promise<BlockNumber>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<String>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface BlockNumberSubscription
  extends Promise<AsyncIterator<BlockNumber>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  authoredBy: () => Promise<AsyncIterator<String>>;
  startDateTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface BlockNumberNullablePromise
  extends Promise<BlockNumber | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  authoredBy: () => Promise<String>;
  startDateTime: () => Promise<DateTimeOutput>;
  hash: () => Promise<String>;
}

export interface StakePreviousValues {
  id: ID_Output;
  totalStake: String;
}

export interface StakePreviousValuesPromise
  extends Promise<StakePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  totalStake: () => Promise<String>;
}

export interface StakePreviousValuesSubscription
  extends Promise<AsyncIterator<StakePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  totalStake: () => Promise<AsyncIterator<String>>;
}

export interface StakeSubscriptionPayload {
  mutation: MutationType;
  node: Stake;
  updatedFields: String[];
  previousValues: StakePreviousValues;
}

export interface StakeSubscriptionPayloadPromise
  extends Promise<StakeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StakePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StakePreviousValuesPromise>() => T;
}

export interface StakeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StakeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StakeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StakePreviousValuesSubscription>() => T;
}

export interface Session {
  id: ID_Output;
  index: Int;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  start: <T = BlockNumberPromise>() => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  start: <T = BlockNumberSubscription>() => T;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  start: <T = BlockNumberPromise>() => T;
}

export interface SlashingPreviousValues {
  id: ID_Output;
  who: String;
  amount: String;
}

export interface SlashingPreviousValuesPromise
  extends Promise<SlashingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  who: () => Promise<String>;
  amount: () => Promise<String>;
}

export interface SlashingPreviousValuesSubscription
  extends Promise<AsyncIterator<SlashingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  who: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface SlashingEdge {
  node: Slashing;
  cursor: String;
}

export interface SlashingEdgePromise
  extends Promise<SlashingEdge>,
    Fragmentable {
  node: <T = SlashingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SlashingEdgeSubscription
  extends Promise<AsyncIterator<SlashingEdge>>,
    Fragmentable {
  node: <T = SlashingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PreimageArgumentConnection {
  pageInfo: PageInfo;
  edges: PreimageArgumentEdge[];
}

export interface PreimageArgumentConnectionPromise
  extends Promise<PreimageArgumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreimageArgumentEdge>>() => T;
  aggregate: <T = AggregatePreimageArgumentPromise>() => T;
}

export interface PreimageArgumentConnectionSubscription
  extends Promise<AsyncIterator<PreimageArgumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreimageArgumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreimageArgumentSubscription>() => T;
}

export interface ProposalEdge {
  node: Proposal;
  cursor: String;
}

export interface ProposalEdgePromise
  extends Promise<ProposalEdge>,
    Fragmentable {
  node: <T = ProposalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProposalEdgeSubscription
  extends Promise<AsyncIterator<ProposalEdge>>,
    Fragmentable {
  node: <T = ProposalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RewardEdge {
  node: Reward;
  cursor: String;
}

export interface RewardEdgePromise extends Promise<RewardEdge>, Fragmentable {
  node: <T = RewardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RewardEdgeSubscription
  extends Promise<AsyncIterator<RewardEdge>>,
    Fragmentable {
  node: <T = RewardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "BlockNumber",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "Era",
    embedded: false
  },
  {
    name: "Slashing",
    embedded: false
  },
  {
    name: "Validator",
    embedded: false
  },
  {
    name: "TotalIssuance",
    embedded: false
  },
  {
    name: "Reward",
    embedded: false
  },
  {
    name: "Nomination",
    embedded: false
  },
  {
    name: "Stake",
    embedded: false
  },
  {
    name: "Proposal",
    embedded: false
  },
  {
    name: "ProposalArgument",
    embedded: false
  },
  {
    name: "Preimage",
    embedded: false
  },
  {
    name: "PreimageStatus",
    embedded: false
  },
  {
    name: "PreimageArgument",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
